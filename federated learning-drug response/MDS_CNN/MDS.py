import pickle
import numpy as np
import pandas as pd
import os
import cv2
import matplotlib.pyplot as plt
import scipy.misc
import Toolbox
from Toolbox import two_d_eq, Assign_features_to_pixels
from sklearn.manifold import MDS
from sklearn.metrics.pairwise import euclidean_distances
import math

# %% Loading the data
Feat_DF = pd.read_csv("GDSC2_Expr_CGC_feature.csv")

X = Feat_DF.values;
X = X[:, 2:]
original_input = pd.DataFrame(data=X)  # The MDS input should be in a dataframe format
original_input = original_input.dropna(how='all')
feature_names_list = original_input.columns.tolist()  # Extracting feature_names_list (gene_names or descriptor_names)
print(">>>> Data  is loaded")

# %% MDS
nn = math.ceil(np.sqrt(len(feature_names_list)))  # Image dimension
Nn = original_input.shape[1]  # Number of features

transposed_input = original_input.T  # The MDS input data must be transposed , because we want summarize each feature by two values (as compard to regular dimensionality reduction each sample will be described by two values)
Euc_Dist = euclidean_distances(transposed_input)  # Euclidean distance
Euc_Dist = np.maximum(Euc_Dist, Euc_Dist.transpose())  # Making the Euclidean distance matrix symmetric

embedding = MDS(n_components=2)  # Reduce the dimensionality by MDS into 2 components
mds_xy = embedding.fit_transform(transposed_input)  # Apply MDS

print(">>>> MDS dimensionality reduction is done")

eq_xy = two_d_eq(mds_xy, Nn)
Img = Assign_features_to_pixels(eq_xy, nn, verbose=1)  # Img is the none-overlapping coordinates generated by MDS

init_map = np.char.strip(Img.astype(str),'F').astype(int)
map_in_int = init_map
coords = np.array([[item[0] for item in np.where(map_in_int == ii)] for ii in range(Nn)])

gene_names = Feat_DF.columns.tolist();
gene_names = gene_names[2:]
data = (gene_names, coords, map_in_int)

with open('MDS_mapping_GDSC2_CGC.pickle', 'wb') as f:
    pickle.dump(data, f)

